# 缓存失效策略

## 1. 引言
缓存失效策略是确保缓存数据新鲜度和一致性的关键。本文档将介绍如何设计有效的缓存失效策略。

## 2. 缓存失效原则
### 2.1 数据变更时失效
- 当数据被更新、删除或插入时，相关缓存应立即失效。

### 2.2 设置过期时间
- 对于不经常变动的数据，可以设置较长的过期时间。
- 对于经常变动的数据，应设置较短的过期时间。

### 2.3 主动失效与被动失效
- 主动失效：在数据变更时主动使缓存失效。
- 被动失效：缓存达到过期时间后自动失效。

## 3. 缓存失效方法
### 3.1 设置TTL（Time To Live）
- 为每个缓存项设置TTL，过期后自动失效。

### 3.2 发布/订阅机制
- 使用发布/订阅机制，当数据变更时，发布通知，订阅者更新或删除缓存。

### 3.3 事件监听
- 监听数据库变更事件，触发缓存失效。

## 4. 缓存失效示例
### 4.1 主动失效示例
- 当用户更新个人信息时，相关缓存（如用户信息缓存）应立即失效。

### 4.2 被动失效示例
- 用户信息缓存设置TTL为1小时，1小时后缓存自动失效。

## 5. 总结
有效的缓存失效策略可以确保缓存数据的一致性和准确性。根据不同的应用场景和数据特性，选择合适的缓存失效策略至关重要。

shop-app/8. 性能优化/8.2 优化缓存策略/缓存命中率监控.docx
# 缓存命中率监控

## 1. 引言
缓存命中率是衡量缓存效果的重要指标。本文档将介绍如何监控缓存命中率。

## 2. 监控原则
### 2.1 定期监控
- 定期收集缓存命中率数据，如每小时、每天。

### 2.2 指标统计
- 统计缓存命中和未命中的次数。

## 3. 监控方法
### 3.1 自定义监控工具
- 开发自定义监控工具，记录缓存命中和未命中数据。

### 3.2 第三方监控服务
- 使用第三方监控服务，如Prometheus、Grafana等。

## 4. 监控指标
### 4.1 缓存命中率
- 缓存命中率 = (缓存命中次数 / (缓存命中次数 + 缓存未命中次数)) * 100%

### 4.2 缓存未命中次数
- 缓存未命中次数 = 总请求次数 - 缓存命中次数

## 5. 总结
通过监控缓存命中率，可以评估缓存效果，并根据监控数据优化缓存策略。

shop-app/8. 性能优化/8.2 优化缓存策略/缓存预热策略.docx
# 缓存预热策略

## 1. 引言
缓存预热是提高缓存命中率的一种策略。本文档将介绍如何实施缓存预热。

## 2. 预热原则
### 2.1 数据预热
- 在应用启动时或数据变更时，预先加载热点数据到缓存中。

### 2.2 预热时机
- 应用启动时。
- 数据库更新时。

## 3. 预热方法
### 3.1 手动预热
- 通过脚本或手动操作，将热点数据加载到缓存中。

### 3.2 自动预热
- 使用缓存服务提供的自动预热功能。

## 4. 预热示例
### 4.1 手动预热示例
- 在应用启动时，通过脚本将热门商品和用户信息加载到缓存中。

### 4.2 自动预热示例
- 当数据库中的商品信息更新时，自动将更新后的商品信息加载到缓存中。

## 5. 总结
缓存预热可以显著提高缓存命中率，减少数据库的访问压力。

shop-app/8. 性能优化/8.2 优化缓存策略/缓存穿透处理.docx
# 缓存穿透处理

## 1. 引言
缓存穿透是指缓存和数据库中都没有的数据，导致每次请求都直接落到数据库上，从而增加了数据库的压力。本文档将介绍如何处理缓存穿透。

## 2. 处理原则
### 2.1 缓存空对象
- 将空对象也缓存起来，并设置较短的过期时间。

### 2.2 使用布隆过滤器
- 使用布隆过滤器判断数据是否可能存在于数据库中，减少数据库访问。

## 3. 处理方法
### 3.1 缓存空对象
- 当查询结果为空时，将空对象缓存起来。

### 3.2 使用布隆过滤器
- 在查询前，使用布隆过滤器判断数据是否存在。

## 4. 处理示例
### 4.1 缓存空对象示例
- 当查询用户ID为99999的用户时，如果数据库中没有该用户，将空对象缓存起来。

### 4.2 布隆过滤器示例
- 在查询前，使用布隆过滤器判断用户ID是否可能存在于数据库中，如果不存在，则直接返回。

## 5. 总结
通过处理缓存穿透，可以减少数据库的访问压力，提高应用性能。

shop-app/8. 性能优化/8.2 优化缓存策略/缓存雪崩处理.docx
# 缓存雪崩处理

## 1. 引言
缓存雪崩是指缓存中大量数据同时过期，导致请求全部落到数据库上，从而造成数据库压力激增。本文档将介绍如何处理缓存雪崩。

## 2. 处理原则
### 2.1 设置不同的过期时间
- 为不同的缓存数据设置不同的过期时间，避免同时过期。

### 2.2 使用持久化缓存
- 使用持久化缓存，如Redis持久化，防止缓存数据全部丢失。

## 3. 处理方法
### 3.1 设置不同的过期时间
- 为热点数据设置不同的过期时间，如1分钟、5分钟、10分钟。

### 3.2 使用持久化缓存
- 使用Redis持久化，将缓存数据写入磁盘。

## 4. 处理示例
### 4.1 设置不同的过期时间示例
- 为热门商品缓存设置1分钟过期，为用户信息缓存设置5分钟过期。

### 4.2 使用持久化缓存示例
- 使用Redis持久化，将缓存数据写入磁盘。

## 5. 总结
通过处理缓存雪崩，可以防止数据库压力激增，保证应用稳定运行。

shop-app/8. 性能优化/8.2 优化缓存策略/缓存击穿处理.docx
# 缓存击穿处理

## 1. 引言
缓存击穿是指热点数据过期时，大量的请求直接落到数据库上，导致数据库压力激增。本文档将介绍如何处理缓存击穿。

## 2. 处理原则
### 2.1 设置热点数据永不过期
- 为热点数据设置永不过期，或者设置非常长的过期时间。

### 2.2 使用互斥锁
- 使用互斥锁，确保热点数据在过期时只有一个请求去查询数据库。

## 3. 处理方法
### 3.1 设置热点数据永不过期
- 为热点数据设置永不过期，或者设置非常长的过期时间。

### 3.2 使用互斥锁
- 在热点数据过期时，使用互斥锁，确保只有一个请求去查询数据库。

## 4. 处理示例
### 4.1 设置热点数据永不过期示例
- 为热门商品缓存设置永不过期。

### 4.2 使用互斥锁示例
- 在热点数据过期时，使用互斥锁，确保只有一个请求去查询数据库。

## 5. 总结
通过处理缓存击穿，可以防止数据库压力激增，保证应用稳定运行。